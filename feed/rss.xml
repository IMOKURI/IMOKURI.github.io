<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"
    xmlns:dc="http://purl.org/dc/elements/1.1/">
    <channel>
        <title>Wake up! Good night* - 最近の投稿</title>
        <link>https://imokuri123.com</link>
        <description><![CDATA[インフラ系SEのまとめノート]]></description>
        <atom:link href="https://imokuri123.com/feed/rss.xml" rel="self"
                   type="application/rss+xml" />
        <lastBuildDate>Tue, 12 Jan 2016 21:00:00 UT</lastBuildDate>
        <item>
    <title>stackのbuildpackを使って、herokuにHaskellのプログラムをリリースする。</title>
    <link>https://imokuri123.com/blog/2016/01/wai-example-using-buildback-stack.html</link>
    <description><![CDATA[<p>Haskellのプログラムをherokuにリリースしようとして、調べていたところ、<a href="http://qiita.com/eielh/items/e52aeee1419ba611a84d">dockerを使ってリリースする方法</a>が見つかったのですが、なんだかんだでうまく行かず、一旦断念。それはリベンジすることにして、<a href="https://github.com/mfine/heroku-buildpack-stack">buildpackのstack版</a>が見つかったので、それを使って、リリースをしてみました。</p>
<!--more-->
<p>準備するものは、通常のstackのプログラム一式と、herokuでの起動プログラムを指定するProcfileです。</p>
<p>buildpackでデプロイすると、起動プログラムはパスの通っている /app/.local/bin にコピーされるので、Procfileでファイルパスの指定は不要です。</p>
<p><code>web: &lt;起動プログラム名&gt;</code></p>
<p>ソースが準備出来たら、以下の要領で、herokuアプリを作成します。</p>
<p><code>heroku create &lt;アプリ名&gt; --buildpack https://github.com/mfine/heroku-buildpack-stack.git</code></p>
<p>herokuにpushすると、1回目は依存パッケージを含めたbuildが始まります。2回目以降は、インストール済みのパッケージが使えるので、buildの時間はかなり短縮されます。</p>
<p><code>git push heroku master</code></p>
<p>今回作ったレポジトリは<a href="https://github.com/IMOKURI/wai-example-using-buildback-stack">こちら</a>です。</p>]]></description>
    <pubDate>Tue, 12 Jan 2016 21:00:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2016/01/wai-example-using-buildback-stack.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>Github PagesのDefault branchを変えてみた。</title>
    <link>https://imokuri123.com/blog/2015/12/modify-default-branch.html</link>
    <description><![CDATA[<p><a href="https://github.com/IMOKURI">GithubのProfileのページ</a>で、草が生えないなぁと思っていたのです。<br />
Github Pagesのレポジトリを結構更新しているのになぁです。</p>
<p>調べてみると、<a href="https://help.github.com/articles/why-are-my-contributions-not-showing-up-on-my-profile/#commits">草を生やすには、Default branchへの更新でないとダメ</a>と判明。。</p>
<p>であれば、Github PagesのDefault branchを変えてみたらどうだろうか、をやってみました。</p>
<!--more-->
<hr />
<p>このブログはHakyllを使って、作っています。作り方は、「source」ブランチでHakyllのソースを作って、commit &amp; pushすると、Travis CIがbuildして、「master」ブランチにpushしてくれます。</p>
<p>そのため、「master」ブランチへの貢献度は、私 0%、Travis CI君 100%、みたいな感じで、Default branchが「master」だとそりゃ草 生えんわ、って感じです。</p>
<p>もともと、Default branchは、「プルリクなどを受けるベースとなるブランチ」ということで、Hakyllのブログとしては、当然「source」ブランチがデフォルトになって然るべきだろう、ということで、Default branch変更です！</p>
<p>（個人のブログのソースでプルリクなんて考える必要なかと。）</p>
<p>（そりゃいっちゃあおしまいだ）</p>
<p>変更の仕方は簡単で、「Settings」→「Branches」で、「Default branch」を変更すればOKです。</p>
<p>一応、Travis CIでの自動化に影響がないかは確認しました。</p>
<p>これで、また、ちょいちょい草が生えるはず。</p>]]></description>
    <pubDate>Fri, 25 Dec 2015 18:00:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/12/modify-default-branch.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>Hakyllでブログを作る(実践編4)</title>
    <link>https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part4.html</link>
    <description><![CDATA[<p>さて、<a href="/blog/2015/12/how-to-create-blog-with-hakyll-part3.html">前回</a>の続きになります。</p>
<p>最終回は、シンタックスハイライト＋αで締めくくりたいと思います。</p>
<p>カスタマイズしたソースは<a href="https://github.com/IMOKURI/hakyll-blog-example">こちら</a>に公開していますので、適宜ご参照ください。</p>
<!--more-->
<h3 id="目次">目次</h3>
<ul>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part1.html#テンプレ展開">テンプレ展開</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part1.html#ページ作成の流れ">ページ作成の流れ</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#ページネーション">記事一覧を5記事ごとに分割(ページネーション)</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#feed作成">RSS/Atom Feed作成</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part3.html#ティーザー">「続きを読む」のリンク(ティーザー)</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part3.html#タグ付け記事一覧">タグ付けされた記事一覧</a></li>
<li><a href="#シンタックスハイライト">シンタックスハイライト</a></li>
<li><a href="#ブログ公開">【リンク】github pagesで作ったブログを公開</a></li>
</ul>
<p>それでは、さっそくいってみましょう。</p>
<h2 id="シンタックスハイライト">シンタックスハイライト</h2>
<p>pandocでコンパイルしたhtmlのコードブロックには、色付けのためのclassが付与されていますので、そのclassに合わせた色付けのcssが準備できれば良いことになります。</p>
<p>今回は外部パッケージの「<a href="https://hackage.haskell.org/package/highlighting-kate">highlighting-kate</a>」を使って簡単に実装します。</p>
<p>まずは、パッケージをビルドするため、cabalファイルの「build-depends」に「highlighting-kate」を追加しておきましょう。</p>
<p>highlighting-kateには、いくつかカラーバリエーションが有りますので、お好みを選んで、cssファイルを作成します。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">create [<span class="st">&quot;css/highlight.css&quot;</span>] <span class="fu">$</span> <span class="kw">do</span>
    route   idRoute
    compile <span class="fu">$</span> makeItem (compressCss <span class="fu">$</span> K.styleToCss K.pygments)</code></pre></div>
<blockquote>
<p>「K.styleToCss」でお好みのテーマ「K.pygments」をCSSに変換します。<br />
「compressCss」でCSSをぬかりなく圧縮しておきましょう。 カラーテーマは<a href="https://hackage.haskell.org/package/highlighting-kate-0.6/docs/Text-Highlighting-Kate-Styles.html">こちら</a>に一覧があります。</p>
</blockquote>
<p>CSSファイルが出来上がったので、あとはテンプレートで読み込んでおけばOKです。</p>
<h2 id="ブログ公開">ブログ公開</h2>
<p>せっかく作ったブログはぜひ公開したいものです。</p>
<p>そんな時は、Github Pages。(回し者とかではないですが、オススメです)</p>
<p>Github PagesでHakyllで作ったブログを公開するなら、Travis CIと連携して自動化するのが便利です。<br />
<a href="http://335g.github.io/posts/2015-08-09-hakyll_travis.html">参考リンク1</a>, <a href="/blog/2015/04/create-github-pages-with-hakyll.html">参考リンク2</a></p>
<h2 id="デザインについて">デザインについて</h2>
<p>やっぱりブログやるならかっこいいのがいいですよね（笑</p>
<p>Hakyllでは、ブログデザインは、頑張らないといけない感じです（汗<br />
(<a href="http://katychuang.com/hakyll-cssgarden/gallery/">ここ</a>にちょっとテンプレを公開してくれている人もいます)</p>
<p>とはいえ、流石にゼロから作るのはきついので、フリーのボイラープレートなどを利用するのがいいのかな、と思います。</p>
<p>Hakyllは苦痛じゃないけど、デザインは苦痛だという方、一緒に頑張りましょう（笑</p>
<h2 id="コメントについて">コメントについて</h2>
<p>記事の中でよくわからないとか、もっと説明してほしいとか、はもちろんのこと、</p>
<p>Hakyllでこれどうやるの？的なのもコメントに書いても良いのかなと思ったりします。</p>
<p>質問サイトに書くのももちろん良いと思いますが、直接問いかけることができるのがコメント欄に書くメリットですね。</p>
<p>答えられるかどうかは別問題として。。</p>
<hr />
<p><a href="http://yannesposito.com/Scratch/en/blog/Hakyll-setup/">Hakyll setup</a><br />
<a href="http://dannysu.com/2015/10/29/hakyll-pagination/">Pagination with Hakyll</a><br />
<a href="http://jaspervdj.be/hakyll/tutorials/05-snapshots-feeds.html">TUTORIAL: SNAPSHOTS, AND HOW TO PRODUCE AN RSS/ATOM FEED</a><br />
<a href="http://jaspervdj.be/hakyll/tutorials/using-teasers-in-hakyll.html">TUTORIAL: USING TEASERS IN HAKYLL</a><br />
<a href="http://javran.github.io/posts/2014-03-01-add-tags-to-your-hakyll-blog.html">Add tags to your Hakyll blog</a><br />
<a href="http://philopon.github.io/posts/2014/hakyll_tips.html">Hakyll tips</a></p>]]></description>
    <pubDate>Sat, 19 Dec 2015 00:03:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part4.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>Hakyllでブログを作る(実践編3)</title>
    <link>https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part3.html</link>
    <description><![CDATA[<p>さて、<a href="/blog/2015/12/how-to-create-blog-with-hakyll-part2.html">前回</a>の続きになります。</p>
<p>今回は、カスタマイズ後半戦です。</p>
<p>カスタマイズしたソースは<a href="https://github.com/IMOKURI/hakyll-blog-example">こちら</a>に公開していますので、適宜ご参照ください。</p>
<!--more-->
<h3 id="目次">目次</h3>
<ul>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part1.html#テンプレ展開">テンプレ展開</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part1.html#ページ作成の流れ">ページ作成の流れ</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#ページネーション">記事一覧を5記事ごとに分割(ページネーション)</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#feed作成">RSS/Atom Feed作成</a></li>
<li><a href="#ティーザー">「続きを読む」のリンク(ティーザー)</a></li>
<li><a href="#タグ付け記事一覧">タグ付けされた記事一覧</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part4.html#シンタックスハイライト">シンタックスハイライト</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part4.html#ブログ公開">【リンク】github pagesで作ったブログを公開</a></li>
</ul>
<p>それでは、さっそくいってみましょう。</p>
<h2 id="ティーザー">ティーザー</h2>
<p>ブログでは、ときどき、記事の冒頭部分が見えていて、「続きを読む」的なリンクが付いていることがあります。それもやってみましょう。</p>
<p>まずは、ブログの記事に、「どこまで見せておくか」のしるしとして「&lt;!--more--&gt;」を入れておきます。</p>
<p>ここまでのチュートリアルで、記事の本文は、「$body$」の情報で、埋め込まれていました。ティーザーでは、同じように「&lt;!--more--&gt; までの記事」を「$teaser$」として埋め込むことになります。</p>
<p>このとき、記事の内容は、前回つかったスナップショットで保存した記事を使います。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">postCtx ::</span> <span class="dt">Context</span> <span class="dt">String</span>
postCtx <span class="fu">=</span>
    dateField <span class="st">&quot;date&quot;</span> <span class="st">&quot;%B %e, %Y&quot;</span> <span class="ot">`mappend`</span>
    teaserField <span class="st">&quot;teaser&quot;</span> <span class="st">&quot;content&quot;</span> <span class="ot">`mappend`</span>
    defaultContext</code></pre></div>
<p>埋め込まれた情報を使うには、「テンプレートに反映」ということで、「$teaser$」をテンプレートに埋め込めば、ちょいだし記事の完成です。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;ul&gt;</span>
    $for(posts)$
        <span class="kw">&lt;li&gt;</span>
            $title$ - $date$
            $teaser$...<span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$url$&quot;</span><span class="kw">&gt;</span>(続きを読む)<span class="kw">&lt;/a&gt;</span>
        <span class="kw">&lt;/li&gt;</span>
    $endfor$
<span class="kw">&lt;/ul&gt;</span></code></pre></div>
<h2 id="タグ付け記事一覧">タグ付け記事一覧</h2>
<p>記事にどんな情報が載っているか、をタグとしてつけておくのもよくあります。記事にタグをつけつつ、その一覧ページも作ってみましょう。</p>
<p>付与するタグは、記事の冒頭に書いておきます。</p>
<div class="sourceCode"><pre class="sourceCode markdown"><code class="sourceCode markdown">---
title: example post
tags: example, hakyll
---</code></pre></div>
<p>続いて、Haskellのソースの方で、タグのルールを設定します。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">tags <span class="ot">&lt;-</span> buildTags <span class="st">&quot;posts/*&quot;</span> (fromCapture <span class="st">&quot;tags/*.html&quot;</span>)</code></pre></div>
<blockquote>
<p>「&quot;posts/*&quot;」にマッチする記事からタグ情報を収集して、<br />
タグごとのURLは、「tag/*.html」の形にする。<br />
収集したタグの情報は「tags」に入れておく。</p>
</blockquote>
<p>ルールが決まって、タグの情報を収集したので、まずは、記事の方にタグの情報を表示してみましょう。</p>
<p>例によって、タグの情報を埋め込むことになります。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">postCtx ::</span> <span class="dt">Tags</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">String</span>
postCtx tags <span class="fu">=</span>
    dateField <span class="st">&quot;date&quot;</span> <span class="st">&quot;%B %e, %Y&quot;</span>   <span class="ot">`mappend`</span>
    teaserField <span class="st">&quot;teaser&quot;</span> <span class="st">&quot;content&quot;</span> <span class="ot">`mappend`</span>
    tagsField <span class="st">&quot;tags&quot;</span> tags          <span class="ot">`mappend`</span>
    defaultContext</code></pre></div>
<p>「tagsField」を使って埋め込みましょう。この時、タグの情報を「postCtx」の引数に指定する必要があるので、注意しましょう。</p>
<p>埋め込んだ情報を使うためにテンプレートを更新します。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;info&quot;</span><span class="kw">&gt;</span>
    $if(tags)$
        Tags: $tags$
    $endif$
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<p>続いて、タグ一覧ページを作りましょう。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">tagsRules tags <span class="fu">$</span> \tag pattern <span class="ot">-&gt;</span> <span class="kw">do</span>
    route   idRoute
    compile <span class="fu">$</span> <span class="kw">do</span>
        posts <span class="ot">&lt;-</span> recentFirst <span class="fu">=&lt;&lt;</span> loadAll pattern
        <span class="kw">let</span> tagCtx <span class="fu">=</span>
                constField <span class="st">&quot;title&quot;</span> (<span class="st">&quot;Posts tagged &quot;</span> <span class="fu">++</span> tag)     <span class="ot">`mappend`</span>
                listField <span class="st">&quot;posts&quot;</span> (postCtx tags) (return posts) <span class="ot">`mappend`</span>
                defaultContext

        makeItem <span class="st">&quot;&quot;</span>
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/tag.html&quot;</span> tagCtx
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> tagCtx
            <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></div>
<p>・・・ページネーションのにそっくりですね♪</p>
<p>ということで、残りは、「tag.html」のテンプレートの準備です。 対象となる記事をリストすればよいので、こんな感じで十分ですね。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html">$partial(&quot;templates/post-list.html&quot;)$</code></pre></div>
<p>おまけで、タグといえば、タグのリストや、タグクラウドも欲しくなります。作り方はほぼ同じなので、ここでは、タグクラウドを作って、トップページに貼り付けておきたいと思います。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;index.html&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    route   idRoute
    compile <span class="fu">$</span> <span class="kw">do</span>
        posts <span class="ot">&lt;-</span> fmap (take <span class="dv">3</span>) <span class="fu">.</span> recentFirst <span class="fu">=&lt;&lt;</span> loadAll <span class="st">&quot;posts/*&quot;</span>
        tagCloud <span class="ot">&lt;-</span> renderTagCloud <span class="fl">80.0</span> <span class="fl">120.0</span> tags
        <span class="kw">let</span> indexCtx <span class="fu">=</span>
                listField <span class="st">&quot;posts&quot;</span> (postCtx tags) (return posts) <span class="ot">`mappend`</span>
                constField <span class="st">&quot;title&quot;</span> <span class="st">&quot;Home&quot;</span>                       <span class="ot">`mappend`</span>
                constField <span class="st">&quot;tagcloud&quot;</span> tagCloud                  <span class="ot">`mappend`</span>
                defaultContext

        getResourceBody
            <span class="fu">&gt;&gt;=</span> applyAsTemplate indexCtx
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> indexCtx
            <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></div>
<blockquote>
<p>タグの情報を読み込み、最小のフォントが80%、最大が120%で、タグクラウドの情報を生成します。 (tagCloud &lt;- renderTagCloud 80.0 120.0 tags)<br />
生成したタグクラウドの情報を「tagcloud」の名前で埋め込んでおきます。 (constField &quot;tagcloud&quot; tagCloud)</p>
</blockquote>
<p>あとはタグクラウドを表示したい場所に、「$tagcloud$」を入れておきましょう。</p>
<p>さて、<a href="/blog/2015/12/how-to-create-blog-with-hakyll-part4.html">次回</a>、最終回に続きますー。</p>]]></description>
    <pubDate>Sat, 19 Dec 2015 00:02:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part3.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>Hakyllでブログを作る(実践編2)</title>
    <link>https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part2.html</link>
    <description><![CDATA[<p>さて、<a href="/blog/2015/12/how-to-create-blog-with-hakyll-part1.html">前回</a>の続きになります。</p>
<p>今回は、テンプレートを離れて、いろいろカスタマイズしていきます。</p>
<p>カスタマイズしたソースは<a href="https://github.com/IMOKURI/hakyll-blog-example">こちら</a>に公開していますので、適宜ご参照ください。</p>
<!--more-->
<h3 id="目次">目次</h3>
<ul>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part1.html#テンプレ展開">テンプレ展開</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part1.html#ページ作成の流れ">ページ作成の流れ</a></li>
<li><a href="#ページネーション">記事一覧を5記事ごとに分割(ページネーション)</a></li>
<li><a href="#feed作成">RSS/Atom Feed作成</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part3.html#ティーザー">「続きを読む」のリンク(ティーザー)</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part3.html#タグ付け記事一覧">タグ付けされた記事一覧</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part4.html#シンタックスハイライト">シンタックスハイライト</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part4.html#ブログ公開">【リンク】github pagesで作ったブログを公開</a></li>
</ul>
<p>それでは、さっそくいってみましょう。</p>
<h2 id="ページネーション">ページネーション</h2>
<p>前回確認したテンプレートの中の、「Archives」のページは、過去記事一覧ということで、記事を追加していくと、(たぶん)際限なくリストされていきます。それはそれで気分がいいかもしれませんが、記事の一覧は、ある程度の単位(5個とか10個とか)でページが分割されてほしいものです。それをやってみます。</p>
<p>まずは、「どんなルールでページネーションをするか」を設定します。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">archive <span class="ot">&lt;-</span> buildPaginateWith
    (sortRecentFirst <span class="fu">&gt;=&gt;</span> return <span class="fu">.</span> paginateEvery <span class="dv">5</span>)
    <span class="st">&quot;posts/*&quot;</span>
    (\n <span class="ot">-&gt;</span> <span class="kw">if</span> n <span class="fu">==</span> <span class="dv">1</span>
           <span class="kw">then</span> fromFilePath <span class="st">&quot;archive.html&quot;</span>
           <span class="kw">else</span> fromFilePath <span class="fu">$</span> <span class="st">&quot;archive/&quot;</span> <span class="fu">++</span> show n <span class="fu">++</span> <span class="st">&quot;.html&quot;</span>)</code></pre></div>
<p>こちらのソースは以下の様な意味になります。</p>
<blockquote>
<p>記事が新しい順に、5記事で1ページにする。 ((sortRecentFirst &gt;=&gt; return . paginateEvery 5))<br />
ページネーションの対象になるのは &quot;posts/*&quot; にマッチする記事。<br />
ページネーションの1ページ目のURLは http://user.github.io/archive.html<br />
2ページ目以降のURLは http://user.github.io/archive/ページ番号.html</p>
</blockquote>
<p>ルールが決まったので、何ページ目にどの記事が入るか、が決まりました。 次に、ページネーションのページごとに、実際のページを組み立てていきます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">paginateRules archive <span class="fu">$</span> \pageNum pattern <span class="ot">-&gt;</span> <span class="kw">do</span>
    route   idRoute
    compile <span class="fu">$</span> <span class="kw">do</span>
        posts <span class="ot">&lt;-</span> recentFirst <span class="fu">=&lt;&lt;</span> loadAll pattern
        <span class="kw">let</span> archiveCtx <span class="fu">=</span>
                constField <span class="st">&quot;title&quot;</span> <span class="st">&quot;Archives&quot;</span>            <span class="ot">`mappend`</span>
                listField <span class="st">&quot;posts&quot;</span> postCtx (return posts) <span class="ot">`mappend`</span>
                paginateContext archive pageNum          <span class="ot">`mappend`</span>
                defaultContext

        makeItem <span class="st">&quot;&quot;</span>
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/archive.html&quot;</span> archiveCtx
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> archiveCtx
            <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></div>
<blockquote>
<p>ページネーションのページ番号は 「pageNum」、対象となる記事は 「pattern」に入ります。<br />
「paginateContext」では、ページネーションに必要な「$nextPageNum$」や、「$nextPageUrl$」などの情報が埋め込まれます。その他の埋め込まれる情報は<a href="https://github.com/jaspervdj/hakyll/blob/master/src/Hakyll/Web/Paginate.hs#L99-L109">こちら</a>を参照ください。</p>
</blockquote>
<p>組み立てたページを反映させるテンプレート 「archive.html」で、埋め込んだ情報を書いていきましょう。具体的には、各ページネーションのページに、「次のページ」や「最後のページ」のリンクを作っていきます。このとき、「最後のページ」には、その次のページはありませんので、「次のページ」が存在するときのみ、リンクを作成する、となるようif文を使っていきます。</p>
<div class="sourceCode"><pre class="sourceCode html"><code class="sourceCode html"><span class="kw">&lt;div</span><span class="ot"> class=</span><span class="st">&quot;pagination&quot;</span><span class="kw">&gt;</span>
  $if(firstPageUrl)$
    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$firstPageUrl$&quot;</span><span class="kw">&gt;</span><span class="dv">&amp;lt;&amp;lt;&amp;nbsp;</span>First<span class="kw">&lt;/a&gt;</span><span class="dv">&amp;nbsp;</span>
  $endif$
  $if(previousPageUrl)$
    <span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$previousPageUrl$&quot;</span><span class="kw">&gt;</span><span class="dv">&amp;lt;&amp;nbsp;</span>Previous<span class="kw">&lt;/a&gt;</span><span class="dv">&amp;nbsp;</span>
  $endif$
  <span class="dv">&amp;mdash;</span>
  $currentPageNum$ of $numPages$
  <span class="dv">&amp;mdash;</span>
  $if(nextPageUrl)$
    <span class="dv">&amp;nbsp;</span><span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$nextPageUrl$&quot;</span><span class="kw">&gt;</span>Next<span class="dv">&amp;nbsp;&amp;gt;</span><span class="kw">&lt;/a&gt;</span>
  $endif$
  $if(lastPageUrl)$
    <span class="dv">&amp;nbsp;</span><span class="kw">&lt;a</span><span class="ot"> href=</span><span class="st">&quot;$lastPageUrl$&quot;</span><span class="kw">&gt;</span>Last<span class="dv">&amp;nbsp;&amp;gt;&amp;gt;</span><span class="kw">&lt;/a&gt;</span>
  $endif$
<span class="kw">&lt;/div&gt;</span></code></pre></div>
<h2 id="feed作成">Feed作成</h2>
<p>HakyllはRSSとAtomのFeedが作成できるようになっています。HakyllでFeedを作ろうとした時、Feedに載る記事は当然HTMLに変換されていて欲しいのですが、記事のページ全体は必要ありません（ナビゲーションバーとか）。そこで、記事の内容をHTMLに変換したあと、記事のページ全体にする（default.htmlのテンプレートを反映させる）前の状態をsnapshotとして保存しておくことができます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;posts/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    route <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
    compile <span class="fu">$</span> pandocCompiler
        <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/post.html&quot;</span>    postCtx
        <span class="fu">&gt;&gt;=</span> saveSnapshot <span class="st">&quot;content&quot;</span>
        <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> postCtx
        <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></div>
<blockquote>
<p>「&quot;posts/*&quot;」にマッチするドキュメントを、pandocでHTMLに変換し、「post.html」のテンプレートを反映した状態の記事を、<br />
「content」という名前で保存して、そっとしておく。 (saveSnapshot &quot;content&quot;)<br />
その後の処理は継続して、続けていく。</p>
</blockquote>
<p>という感じで、保存したスナップショットをFeedを作るときに利用します。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">create [<span class="st">&quot;atom.xml&quot;</span>] <span class="fu">$</span> <span class="kw">do</span>
    route   idRoute
    compile <span class="fu">$</span> <span class="kw">do</span>
        <span class="kw">let</span> feedCtx <span class="fu">=</span>
                postCtx                 <span class="ot">`mappend`</span>
                bodyField <span class="st">&quot;description&quot;</span>
        posts <span class="ot">&lt;-</span> fmap (take <span class="dv">10</span>) <span class="fu">.</span> recentFirst <span class="fu">=&lt;&lt;</span> loadAllSnapshots <span class="st">&quot;posts/*&quot;</span> <span class="st">&quot;content&quot;</span>
        renderAtom myFeedConfiguration feedCtx posts</code></pre></div>
<blockquote>
<p>「loadAllSnapshots」で、「&quot;content&quot;」に保存したsnapshotを読み込みます。 (loadAllSnapshots &quot;posts/*&quot; &quot;content&quot;)<br />
読み込んだ記事を、新しい順に前から10件取得します。 (fmap (take 10) . recentFirst)<br />
取得した10件でAtomフィードのページを作ります。 (renderAtom myFeedConfiguration feedCtx posts)</p>
</blockquote>
<p>最後に、「myFeedConfiguration」を準備しておきます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">myFeedConfiguration ::</span> <span class="dt">FeedConfiguration</span>
myFeedConfiguration <span class="fu">=</span> <span class="dt">FeedConfiguration</span>
    { feedTitle       <span class="fu">=</span> <span class="st">&quot;My Hakyll Blog&quot;</span>
    , feedDescription <span class="fu">=</span> <span class="st">&quot;Hakyllでブログを作る&quot;</span>
    , feedAuthorName  <span class="fu">=</span> <span class="st">&quot;username&quot;</span>
    , feedAuthorEmail <span class="fu">=</span> <span class="st">&quot;test@example.com&quot;</span>
    , feedRoot        <span class="fu">=</span> <span class="st">&quot;http://user.github.io&quot;</span>
    }</code></pre></div>
<p>ということで、だいぶブログっぽくなってきました。</p>
<p><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part3.html">次回</a>は、カスタマイズ後半戦です。</p>]]></description>
    <pubDate>Sat, 19 Dec 2015 00:01:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part2.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>Hakyllでブログを作る(実践編)</title>
    <link>https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part1.html</link>
    <description><![CDATA[<p>Haskellのアドベントカレンダー初参加です。よろしくお願いします。</p>
<p>このサイトは<a href="http://jaspervdj.be/hakyll/">Hakyll</a>で運営しています。</p>
<p>少しずつノウハウが溜まってきたのでまとめてみたいと思います。</p>
<p>Hakyllのチュートリアル的な内容になっています。</p>
<!--more-->
<h3 id="目次">目次</h3>
<ul>
<li><a href="#テンプレ展開">テンプレ展開</a></li>
<li><a href="#ページ作成の流れ">ページ作成の流れ</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#ページネーション">記事一覧を5記事ごとに分割(ページネーション)</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part2.html#feed作成">RSS/Atom Feed作成</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part3.html#ティーザー">「続きを読む」のリンク(ティーザー)</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part3.html#タグ付け記事一覧">タグ付けされた記事一覧</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part4.html#シンタックスハイライト">シンタックスハイライト</a></li>
<li><a href="/blog/2015/12/how-to-create-blog-with-hakyll-part4.html#ブログ公開">【リンク】github pagesで作ったブログを公開</a></li>
</ul>
<p>それでは、さっそくいってみましょう。</p>
<h2 id="テンプレ展開">テンプレ展開</h2>
<p>stackには、hakyll用のテンプレートが準備されていますので、それを使っていきます。</p>
<p><code>stack new</code> を打つ前に、 「~/.stack/config.yaml」 に以下の様な情報を書いておくとテンプレに載せてくれます。</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">templates:</span>
  <span class="fu">params:</span>
    <span class="fu">author-email:</span> &lt; mail address &gt;
    <span class="fu">author-name:</span> &lt; your name &gt;
    <span class="fu">copyright:</span> 2015, &lt; your name &gt;
    <span class="fu">github-username:</span> &lt; github user name &gt;
    <span class="fu">category:</span> Web <span class="co"># なんでも良いです。</span></code></pre></div>
<p>テンプレを展開してみましょう。</p>
<p><code>stack new &lt;プロジェクト名&gt; hakyll-template</code></p>
<p>プロジェクト名は何でも良いので、おためしだったら 「myblog」 とか、github pagesで公開するなら 「githubのユーザ名-github-io」 みたいなのが良いかと思います。ここでは、 「user-github-io」 として進めていきます。</p>
<p>テンプレを展開したら、cabalファイル 「user-github-io.cabal」 内の 「executable」 の名称を 「site」 などタイピングしやすい単語にしておきましょう。<br />
webページをビルドするときに実行するので、あとあとハッピーです。ここでは、 「site」 に変更したとして進めていきます。</p>
<p><code>stack build</code> でhakyllをセットアップしておきましょう。</p>
<p>以降、Haskellのソースを修正した時は <code>stack build</code> をして、</p>
<p><code>stack exec site build</code> (2回目以降は、 「rebuild」 )で、webページをビルドして、</p>
<p><code>stack exec site watch</code> で、テスト用のサーバが、 http://127.0.0.1:8000 で立ち上がります。</p>
<h2 id="ページ作成の流れ">ページ作成の流れ</h2>
<p>Hakyllで、webページを作るときは、</p>
<ol style="list-style-type: decimal">
<li>markdownなどで、記事を書き、</li>
<li>それが、htmlに変換されて、</li>
<li>テンプレートに埋め込まれる。</li>
</ol>
<p>のが基本イメージです。</p>
<p><img src="/images/2015-12-hakyll-page-structure.png" alt="Hakyll page structure" /><br />
 「どの記事と、どのテンプレートをあわせて、webサイトのどこに表示する」とか、「この記事にこの情報を埋め込む」とか、をHaskellのプログラム(デフォルトは 「site.hs」 )で作っていきます。</p>
<p>たとえば、 「site.hs」 をのぞいてみると、以下の様なソースがあります。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">match <span class="st">&quot;images/*&quot;</span> <span class="fu">$</span> <span class="kw">do</span>
    route   idRoute
    compile copyFileCompiler</code></pre></div>
<p>これは、</p>
<blockquote>
<p>「images/*」 にマッチするファイルを、<br />
webサイトの同じパス 「http://user.github.io/images/*」 に (idRoute)<br />
そのままコピーする。 (copyFileCompiler)</p>
</blockquote>
<p>ということです。</p>
<p>はたまた、以下の様なソースは、</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">match (fromList [<span class="st">&quot;about.rst&quot;</span>, <span class="st">&quot;contact.markdown&quot;</span>]) <span class="fu">$</span> <span class="kw">do</span>
    route   <span class="fu">$</span> setExtension <span class="st">&quot;html&quot;</span>
    compile <span class="fu">$</span> pandocCompiler
        <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> defaultContext
        <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></div>
<blockquote>
<p>「abount.rst」 と 「contact.markdown」 を、<br />
拡張子を 「html」 に変換して、 (setExtension &quot;html&quot;)<br />
中身は、pandocでhtmlに変換して、 (pandocCompiler)<br />
「default.html」 のテンプレートを適用して、 (loadAndApplyTemplate &quot;templates/default.html&quot; defaultContext)<br />
記事の中のURLを相対パスに書き換える。 (relativizeUrls)</p>
</blockquote>
<p>となります。</p>
<blockquote>
<p>テンプレートを適用するときの 「defaultContext」 には、本文やタイトルを表す 「$body$」 や 「$title$」 などの情報が埋め込まれるようになっています。</p>
</blockquote>
<p>追加で、情報を埋め込むときは、 Context に埋め込む情報をまとめて、テンプレートに合わせる、というやり方になります。</p>
<p>例えば、以下は、 「defaultContext」 の情報に、「ブログ記事の日時」の情報を(ファイル名などから)抽出して、追加しています。すると、テンプレート内の 「$date$」 がブログ記事の日時の情報に変換されます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">postCtx ::</span> <span class="dt">Context</span> <span class="dt">String</span>
postCtx <span class="fu">=</span>
    dateField <span class="st">&quot;date&quot;</span> <span class="st">&quot;%B %e, %Y&quot;</span> <span class="ot">`mappend`</span>
    defaultContext</code></pre></div>
<p>他にも、複数の記事をまとめて、新たに一覧のページを作ることもできます。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">create [<span class="st">&quot;archive.html&quot;</span>] <span class="fu">$</span> <span class="kw">do</span>
    route idRoute
    compile <span class="fu">$</span> <span class="kw">do</span>
        posts <span class="ot">&lt;-</span> recentFirst <span class="fu">=&lt;&lt;</span> loadAll <span class="st">&quot;posts/*&quot;</span>
        <span class="kw">let</span> archiveCtx <span class="fu">=</span>
                listField <span class="st">&quot;posts&quot;</span> postCtx (return posts) <span class="ot">`mappend`</span>
                constField <span class="st">&quot;title&quot;</span> <span class="st">&quot;Archives&quot;</span>            <span class="ot">`mappend`</span>
                defaultContext

        makeItem <span class="st">&quot;&quot;</span>
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/archive.html&quot;</span> archiveCtx
            <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/default.html&quot;</span> archiveCtx
            <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></div>
<p>こちらは、次のようになります。</p>
<blockquote>
<p>「archive.html」 というページを以下の通り作ります。(一部省略)<br />
「posts/」 配下の記事を全て読み込んで、日付が新しい順に並べて 「posts」 に格納。 (posts &lt;- recentFirst =&lt;&lt; loadAll &quot;posts/*&quot;)<br />
記事の情報を 「$posts$」 として使えるよう情報を埋め込み。 (listField &quot;posts&quot; postCtx (return posts))<br />
「archive.html」 と 「default.html」 のテンプレートを反映させる。</p>
</blockquote>
<p>テンプレートの方は、どうなっているかというと、 「archive.html」 では、 「<span class="math inline">$partial(&quot;templates/post-list.html&quot;)$</span>」 となっていて、これは、 「post-list.html」 の内容を埋め込むということなので、</p>
<p>「post-list.html」 の方を見ると、以下のようになっていて、</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="fu">$</span>for(posts)<span class="fu">$</span>
    <span class="fu">&lt;</span>li<span class="fu">&gt;</span>
        <span class="fu">&lt;</span>a href<span class="fu">=</span><span class="st">&quot;$url$&quot;</span><span class="fu">&gt;$</span>title<span class="fu">$&lt;/</span>a<span class="fu">&gt;</span> <span class="fu">-</span> <span class="fu">$</span>date<span class="fu">$</span>
    <span class="fu">&lt;/</span>li<span class="fu">&gt;</span>
<span class="fu">$</span>endfor<span class="fu">$</span></code></pre></div>
<blockquote>
<p>「$posts$」 に埋め込まれた記事の情報分繰り返す。 ($for(posts)$)</p>
</blockquote>
<p>という使い方ができるようになっています。</p>
<p>それぞれの関数がどんな役割をしているか、を確認するには、<a href="https://hackage.haskell.org/package/hakyll-4.7.4.0/docs/doc-index-All.html">HackageのIndexのページ</a>で検索するのが、便利です。</p>
<p>さて、ここまでで、デフォルトのテンプレートの中身がだいたい把握できたかと思います。<a href="/blog/2015/12/how-to-create-blog-with-hakyll-part2.html">次の記事</a>では、脱テンプレートということで、いろいろカスタマイズしていきたいと思います。</p>
<p>よくわからないところなどあれば、コメントいただければと思います。</p>]]></description>
    <pubDate>Sat, 19 Dec 2015 00:00:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/12/how-to-create-blog-with-hakyll-part1.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>Github DesktopとAtomでブログの記事を書いてみる</title>
    <link>https://imokuri123.com/blog/2015/10/write-blog-with-atom-and-github-desktop.html</link>
    <description><![CDATA[<p>このブログはgithub pagesで運営しています。</p>
<p>いつもは、Linuxから記事を書いているのですが、ちょっと趣向をかえて、Github DesktopとAtomを使って、Windows上から記事を書いてみたいと思います。</p>
<p>使ってみたのは、こちらです。</p>
<ul>
<li>GitHub Desktop</li>
<li>Atom</li>
<li>Atomのパッケージのmarkdown-writer</li>
</ul>
<p>特に、markdown-writerがそこそこ使えそうなので、さわってみました。</p>
<!--more-->
<p>Github Desktopはインストールして、起動して、github pages用のレポジトリをクローンしておきます。（雑）</p>
<p>Atomもインストールして、起動して、お好みのパッケージとmarkdown-writerを入れておきます。（ry</p>
<h3 id="markdown-writerの設定">markdown-writerの設定</h3>
<p>ここからが本題です。</p>
<p>markdown-writerでブログを書きやすくするため、各設定を入れていきます。</p>
<p>まず、 <code>Site Local Directory</code> にクローンしたレポジトリのディレクトリを入れます。</p>
<p>Windowsの場合、<code>C:\Users\&lt;ユーザ名&gt;\Documents\GitHub\&lt;レポジトリ名&gt;\</code> みたいな感じになるかと思います。</p>
<p>デフォルトのファイルパスは、スラッシュ(/)区切りで書いてありますが、ここはWindowsらしくバックスラッシュ(\)でOKです。</p>
<p>続いて、 <code>Site Drafts Directory</code> や <code>Site Posts Directory</code> に上記のディレクトリからの相対パスを入れます。</p>
<p><code>drafts\</code> や <code>{year}\{month}\</code> のような感じです。</p>
<p><code>New Draft File Name</code> や <code>New Post File Name</code> も好みに合わせて変えておきます。</p>
<h3 id="記事を書く">記事を書く</h3>
<p>基本的な設定は、ひとまずこのくらいで実際に記事を書いてみます。</p>
<p>Atomで、コマンドパレット(Ctrl+Shift+P)を開き、 <code>new draft</code>！で、記事のタイトルなどを入力すると、先ほどの下書き用ディレクトリに、ファイルが出来上がります。</p>
<p>最初に挿入されるテンプレが気に入らなければ、[File]→[Open Your Config]で、以下の様なブロックを追加すれば、変更できます。</p>
<pre><code>  &quot;markdown-writer&quot;:
    frontMatter: &quot;&quot;&quot;
    ---
    date: &lt;date&gt;
    slug: &lt;title&gt;
    title: title in japanese
    categories: category
    tags: aaa,bbb,ccc
    ---


    &lt;!--more--&gt;
    &quot;&quot;&quot;</code></pre>
<p>記事を書くにあたっても、markdown-writerには、markdownを書くのに便利なコマンドが用意されているので、コマンドパレットを開いて、ゴニョゴニョ書いていくと、結構スイスイかけます。</p>
<h3 id="公開ディレクトリに移す">公開ディレクトリに移す</h3>
<p>わざわざ、エクスプローラーを開いて移動する必要はありません。</p>
<p>大活躍のコマンドパレットで <code>publish draft</code>！で、先ほどの下書きディレクトリから、公開ディレクトリに移動してくれます。</p>
<p>あとは、Github Desktopで、commitして、syncすればOKです。</p>
<p>注意点として、文字コードをUTF-8にしておかないと、GitHub Desktopで文字化けてしまいます。</p>
<p>Windows環境だと、普段はSJISで書いている人も多いと思いますので、記事を書き始める前に、AtomのワークスペースをUTF-8にしてくださいませ。(ステータスバーの右下の方をクリック。もしくは[Ctrl+Shift+U]からのUTF-8)</p>
<p>快適なブログ書きを～</p>]]></description>
    <pubDate>Tue, 27 Oct 2015 00:00:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/10/write-blog-with-atom-and-github-desktop.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>DNFを使ってFedoraをアップグレードする（Fedora22->23）</title>
    <link>https://imokuri123.com/blog/2015/10/upgrade-fedora-using-dnf.html</link>
    <description><![CDATA[<p>Fedora 23から DNF を使って、Fedoraをアップグレードするのが<a href="https://fedoraproject.org/wiki/DNF_system_upgrade">推奨</a>となるようですので、早速試してみたいと思います。</p>
<p>Fedora 23はこの記事を書いている時点ではベータ版ですが、DNFでのアップグレードができました。</p>
<!--more-->
<h3 id="まずはアップグレードに必要なパッケージをインストールします">まずは、アップグレードに必要なパッケージをインストールします。</h3>
<pre><code>sudo dnf install dnf-plugin-system-upgrade --enablerepo=updates-testing</code></pre>
<h3 id="続いてアップグレードしたいバージョン今回はfedora-23のパッケージをダウンロードします">続いて、アップグレードしたいバージョン(今回はFedora 23)のパッケージをダウンロードします。</h3>
<pre><code>sudo dnf system-upgrade download --releasever=23</code></pre>
<p>私の環境では、1600パッケージ（1.2GB！）ほどがダウンロードの対象となりました。</p>
<h3 id="アップグレードします">アップグレードします！</h3>
<pre><code>sudo dnf system-upgrade reboot</code></pre>
<p>OSが再起動して、起動中に先ほどダウンロードしたパッケージがインストールされていきます。所要時間20分ほどでしょうか。</p>
<h3 id="無事アップグレード完了">無事、アップグレード完了</h3>
<pre><code>$ cat /etc/fedora-release
Fedora release 23 (Twenty Three)</code></pre>]]></description>
    <pubDate>Mon, 26 Oct 2015 00:00:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/10/upgrade-fedora-using-dnf.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>KeterでYesodを動かす。</title>
    <link>https://imokuri123.com/blog/2015/09/yesod-deployments-with-keter.html</link>
    <description><![CDATA[<p>KeterとNginxを使って、Yesodをdaemonとして起動してみたので、まとめです。</p>
<p>結果として、</p>
<ul>
<li>Yesodはsandboxにインストールする。</li>
<li>本番環境には、バイナリのみ配置する。(今回は便宜上同じ環境です・・)</li>
</ul>
<p>な感じで動作できそうな感じになりました。</p>
<p>ただ、cabal hellが怖くない(？)本番環境などでは、sandboxが消えちゃった時のことを考えると(そんなこと考えるのはおかしいかもですが、、)globalな環境にインストールしちゃっても良いのかもしれません。</p>
<!--more-->
<p>今回の環境は、以下のとおりです。</p>
<ul>
<li>Fedora 22</li>
<li>Haskell-Platform 2014.2</li>
<li>GHC 7.8.4</li>
<li>Nginx 1.8.0</li>
</ul>
<p>stackはまだ勉強中なので、、cabalを使っています。。</p>
<h2 id="yesodをインストールする">Yesodをインストールする</h2>
<p>YesodとKeterをsandboxにインストールします。安心してインストールできるようにLTS Haskellを使いました。</p>
<pre><code>$ mkdir yesod &amp;&amp; cd yesod
$ cabal sandbox init

## (執筆時点の)最新のLTS HaskellはGHC 7.10向けなので、LTS2を使います。
$ wget https://www.stackage.org/lts-2/cabal.config

$ cabal update
$ cabal install yesod-bin keter</code></pre>
<p>インストールすると、 <code>./cabal-sandbox/bin</code> 配下にyesodなどのコマンドができています。<br />
やり方としては、スマートではないかもしれませんが、このコマンドを(楽に)使いたいので、パスを通しておきます。</p>
<pre><code>$ export PATH=&quot;＜ほげほげ＞/yesod/.cabal-sandbox/bin:$PATH&quot;
$ yesod init</code></pre>
<p>Yesodのプロジェクトのディレクトリに移動して、またもsandboxでインストールです。<br />
ここはcabalファイルに、細かくバージョンの制限があったので、LTS Haskellはなしでやっちゃいました。</p>
<pre><code>$ cd &lt;プロジェクトのディレクトリ&gt;
$ cabal sandbox init
$ cabal install --only-dependencies</code></pre>
<h2 id="keter用にyesodのプログラムを準備する">Keter用にYesodのプログラムを準備する</h2>
<p>苦悩の末に、Yesodのプロジェクトが出来上がったら、Keterの設定ファイル(config/keter.yml)を更新します。<br />
最低限更新が必要なのは以下かと思います。</p>
<pre><code>user-edited: false    ## 削除

stanzas:
  - type: webapp
    hosts:
      - www.&lt;かっこいいドメイン&gt;.com    ## プロジェクトのドメインに変更</code></pre>
<p>設定ファイルを更新したら、本番環境に持っていくバイナリファイルを作ります。<br />
バイナリファイルの実体は、Yesodのプログラムや設定ファイルをgzipで固めたものです。<br />
出来上がった <code>＜プロジェクト名＞.keter</code> が持っていくバイナリになります。</p>
<pre><code>$ yesod keter</code></pre>
<h2 id="keterの起動準備">Keterの起動準備</h2>
<p>Keterの起動ディレクトリを適当な場所に作成して、起動ファイルを準備します。</p>
<pre><code>$ mkdir keter &amp;&amp; cd keter
$ mkdir etc incoming</code></pre>
<p>incomingディレクトリには、先ほど作ったYesodのプロジェクトのバイナリファイルを配置しておきます。</p>
<p>etcディレクトリには、Keterの起動ファイル(keter.yaml)を準備します。<br />
この環境はsystemdなので、以下のようになりますが、それ以外の環境については巻末のリンクをご参照ください。</p>
<pre><code>root: ＜ほげほげ＞/keter    ## 上で作ったKeterの起動ディレクトリ
nginx:
  start:
    - systemctl
    - start
    - nginx.service
  reload:
    - systemctl
    - reload
    - nginx.service</code></pre>
<p>つづいて、Keterのsystemd用のファイル(/usr/lib/systemd/system/keter.service)を準備します。</p>
<pre><code>[Unit]
Description=Keter Deployment Handler
After=local-fs.target network.target

[Service]
ExecStart=/＜Keterをインストールしたディレクトリ＞/keter /＜Keterの起動ディレクトリ＞/etc/keter.yaml

[Install]
WantedBy=multi-user.target</code></pre>
<p>最後にnginxのProxyの設定(/etc/nginx/nginx.conf)を変更します。</p>
<pre><code>http {
    server {
        server_name  www.&lt;かっこいいドメイン&gt;.com;    ## プロジェクトのドメインに変更
        location / {
            proxy_pass http://localhost:&lt;Yesodのポート番号&gt;;    ## Proxyの設定を追加
        }
    }
}</code></pre>
<h2 id="keter起動">Keter起動！</h2>
<p>起動します。</p>
<pre><code># systemctl start keter.service</code></pre>
<p>うまく行っていれば、設定したドメインでアクセスできるかと思います。</p>
<p>OS起動時に自動で起動するようにするのは、こちらです。</p>
<pre><code># systemctl enable keter.service</code></pre>
<h3 id="参考">参考</h3>
<p><a href="https://pbrisbin.com/posts/yesod_deployments_with_keter/">Yesod Deployments with Keter</a><br />
<a href="http://www.yesodweb.com/book/deploying-your-webapp">Deploying your Webapp</a></p>]]></description>
    <pubDate>Fri, 25 Sep 2015 00:00:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/09/yesod-deployments-with-keter.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>
<item>
    <title>Haskellでニューラルネットワーク</title>
    <link>https://imokuri123.com/blog/2015/07/neural-network-in-haskell.html</link>
    <description><![CDATA[<p>Haskellの<a href="https://ja.wikipedia.org/wiki/ニューラルネットワーク">ニューラルネットワーク</a>のライブラリの<a href="https://hackage.haskell.org/package/LambdaNet">LambdaNet</a>を使って、ニューラルネットワークを構築してみたいと思います。</p>
<p>題材は、ニューラルネットワークの例としてよく使用されるXORをシュミレーションしてみたいと思います。</p>
<!--more-->
<table>
<thead>
<tr class="header">
<th align="left">Input</th>
<th align="left">Output</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left">(0,0)</td>
<td align="left">0</td>
</tr>
<tr class="even">
<td align="left">(0,1)</td>
<td align="left">1</td>
</tr>
<tr class="odd">
<td align="left">(1,0)</td>
<td align="left">1</td>
</tr>
<tr class="even">
<td align="left">(1,1)</td>
<td align="left">0</td>
</tr>
</tbody>
</table>
<hr />
<p>まずは、層（レイヤー）の数と素子（ニューロン）の数を決めます。</p>
<p>1つ目の層が入力層、最後の層が出力層となり、<br />
入力層のニューロンの数は、入力のデータの数、<br />
出力層のニューロンの数は出力のデータの数とします。</p>
<p>それ以外のレイヤーが隠れ層です。<br />
隠れ層の数と、それぞれの層が持つニューロンの数をいくつにすれば良いかは、<br />
いろいろな手法が考えられているようですが、この記事では割愛します。。</p>
<p>今回は、入力層のデータの数が2つ、出力層のデータの数が1つです。 隠れ層は、よくあるXORの例にならい、隠れ層1つ（ニューロン2つ）としたいとおもいます。</p>
<p>続いて、各層のニューロンをどのように接続するかを考えます。 一般的には各ニューロンを接続する・しないのマップで表現されることが考えられそうですが、 LambdaNetのライブラリでは、現状、すべてのニューロンを接続することしかできません。</p>
<p>活性化関数には、sigmoid、tanh、ReLUが用意されています。<br />
今回はsigmoidを使ってみます。</p>
<p>重みとバイアスの初期値はランダムですが、一様なもの（uniforms）と、<br />
正規分布に従うもの（normals）が用意されています。<br />
今回はnormalsを使ってみます。</p>
<p>ここまでの情報で、初期値を持ったニューラルネットワークができます。<br />
ソースはこちらです。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  g <span class="ot">&lt;-</span> newStdGen
  <span class="kw">let</span> l   <span class="fu">=</span> <span class="dt">LayerDefinition</span> sigmoidNeuron <span class="dv">2</span> connectFully
      l&#39;  <span class="fu">=</span> <span class="dt">LayerDefinition</span> sigmoidNeuron <span class="dv">2</span> connectFully
      l&#39;&#39; <span class="fu">=</span> <span class="dt">LayerDefinition</span> sigmoidNeuron <span class="dv">1</span> connectFully

  <span class="kw">let</span> n <span class="fu">=</span> createNetwork normals g [l, l&#39;, l&#39;&#39;]</code></pre></div>
<hr />
<p>次に、誤差逆伝播法（バックプロパゲーション）を使った教師あり学習を作っていきます。</p>
<p>LambdaNetでは、誤差関数（コスト関数）として、二乗誤差関数のみが提供されています。</p>
<p>学習係数は、用途に合わせて調整します。</p>
<p>ニューラルネットワークの更新の方法は、毎回の学習のたびにネットワークを更新するオンライン（online）と、<br />
n回学習ごとに更新するミニバッチ（minibatch n）が用意されています。</p>
<p>学習用のデータとしては、XORのインプットとアウトプットの4パターンを使用します。</p>
<p>準備した学習用のデータで1万回学習するソースがこちらです。</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  <span class="kw">let</span> t <span class="fu">=</span> <span class="dt">BackpropTrainer</span> <span class="dv">3</span> quadraticCost quadraticCost&#39;

  <span class="kw">let</span> dat <span class="fu">=</span> [(fromList [<span class="dv">0</span>, <span class="dv">1</span>], fromList [<span class="dv">1</span>]),
             (fromList [<span class="dv">1</span>, <span class="dv">1</span>], fromList [<span class="dv">0</span>]),
             (fromList [<span class="dv">1</span>, <span class="dv">0</span>], fromList [<span class="dv">1</span>]),
             (fromList [<span class="dv">0</span>, <span class="dv">0</span>], fromList [<span class="dv">0</span>])]

  <span class="kw">let</span> n&#39; <span class="fu">=</span> trainNTimes n t online dat <span class="dv">10000</span></code></pre></div>
<hr />
<p>最後に、学習したネットワークをテストしてみます。</p>
<p>うまくいけば、XORの結果が得られていると思います。<br />
（今回のソースの条件だと、最初の乱数の状況によってはあまりよい結果にならない場合もありそうです・・）</p>
<p>良いケース</p>
<p>==&gt; XOR predictions:<br />
(0,0): fromList [5.9859958e-3]<br />
(1,0): fromList [0.9938293]<br />
(0,1): fromList [0.9938205]<br />
(1,1): fromList [7.5507853e-3]</p>
<p>悪いケース・・・</p>
<p>==&gt; XOR predictions:<br />
(0,0): fromList [5.984603e-3]<br />
(1,0): fromList [0.99414057]<br />
(0,1): fromList [0.4489829]<br />
(1,1): fromList [0.44912618]</p>
<p>この形を基本に様々なケースに拡張してみたいと思います。</p>
<hr />
<p>今回作成したコードは<a href="https://github.com/IMOKURI/nn-sample">こちら</a>です。<br />
LambdaNetの<a href="https://github.com/jbarrow/LambdaNet/blob/master/examples/XOR.hs">こちら</a>のコードを参考にしています。</p>]]></description>
    <pubDate>Wed, 15 Jul 2015 00:00:00 UT</pubDate>
    <guid>https://imokuri123.com/blog/2015/07/neural-network-in-haskell.html</guid>
    <dc:creator>IMOKURI</dc:creator>
</item>

    </channel>
</rss>
